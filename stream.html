<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rust Video Stream</title>

    <style>
        /* =====================
   Apple-Style Glass UI
   ===================== */

        :root {
            --glass-bg: rgba(255, 255, 255, 0.08);
            --glass-border: rgba(255, 255, 255, 0.18);
            --glass-highlight: rgba(255, 255, 255, 0.35);

            --text-primary: #ffffff;
            --text-secondary: rgba(255, 255, 255, 0.7);

            --accent-1: #7c7cff;
            --accent-2: #00f5d4;
            --accent-3: #ff7ad9;
        }

        /* =====================
   Background
   ===================== */
        body {
            margin: 0;
            height: 100vh;
            background:
                radial-gradient(1200px at 10% 10%, #7c7cff33, transparent),
                radial-gradient(1000px at 90% 30%, #00f5d433, transparent),
                radial-gradient(900px at 50% 90%, #ff7ad933, transparent),
                #050507;

            font-family: -apple-system, BlinkMacSystemFont, "SF Pro Display",
                "Segoe UI", Roboto, Helvetica, Arial, sans-serif;

            color: var(--text-primary);
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        /* =====================
   Viewer Container
   ===================== */
        .viewer-container {
            position: relative;
            width: 90%;
            max-width: 1300px;
            aspect-ratio: 16 / 9;

            background: linear-gradient(180deg,
                    rgba(255, 255, 255, 0.12),
                    rgba(255, 255, 255, 0.02));

            backdrop-filter: blur(28px) saturate(160%);
            -webkit-backdrop-filter: blur(28px) saturate(160%);

            border-radius: 22px;
            border: 1px solid var(--glass-border);

            box-shadow:
                0 40px 80px rgba(0, 0, 0, 0.65),
                inset 0 1px 0 var(--glass-highlight);

            overflow: hidden;
            transition: all 0.4s ease;
        }

        /* Fullscreen */
        .viewer-container:fullscreen {
            width: 100vw;
            height: 100vh;
            max-width: none;
            border-radius: 0;
            border: none;
        }

        /* =====================
   Canvas
   ===================== */
        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* =====================
   Placeholder
   ===================== */
        .placeholder {
            position: absolute;
            inset: 0;

            display: flex;
            align-items: center;
            justify-content: center;

            background:
                radial-gradient(circle at center,
                    rgba(255, 255, 255, 0.15),
                    rgba(0, 0, 0, 0.85));

            backdrop-filter: blur(20px);
            z-index: 5;
            transition: opacity 0.5s ease;
        }

        .placeholder.hidden {
            opacity: 0;
            pointer-events: none;
        }

        /* =====================
   Primary Button
   ===================== */
        button {
            font-family: inherit;
            color: white;
            border: none;
            cursor: pointer;
        }

        button.primary {
            display: flex;
            align-items: center;
            gap: 10px;

            padding: 14px 34px;
            font-size: 1rem;
            font-weight: 600;

            background: linear-gradient(135deg,
                    var(--accent-1),
                    var(--accent-2));

            border-radius: 999px;

            box-shadow:
                0 10px 40px rgba(124, 124, 255, 0.45),
                inset 0 1px 0 rgba(255, 255, 255, 0.5);

            transition: transform 0.25s ease, box-shadow 0.25s ease;
        }

        button.primary:hover {
            transform: translateY(-2px) scale(1.05);
            box-shadow:
                0 16px 60px rgba(124, 124, 255, 0.65);
        }

        /* =====================
   Controls (Glass Pill)
   ===================== */
        .controls {
            position: absolute;
            bottom: 28px;
            left: 50%;
            transform: translateX(-50%);

            display: flex;
            gap: 14px;
            align-items: center;

            padding: 10px 18px;

            background: var(--glass-bg);
            backdrop-filter: blur(22px) saturate(180%);
            -webkit-backdrop-filter: blur(22px) saturate(180%);

            border-radius: 999px;
            border: 1px solid var(--glass-border);

            box-shadow:
                0 8px 30px rgba(0, 0, 0, 0.5),
                inset 0 1px 0 var(--glass-highlight);

            opacity: 0;
            transition: opacity 0.4s ease;
        }

        .viewer-container:hover .controls {
            opacity: 1;
        }

        /* Control buttons */
        .controls button {
            width: 42px;
            height: 42px;
            border-radius: 50%;
            background: transparent;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .controls button:hover {
            background: rgba(255, 255, 255, 0.12);
        }

        /* =====================
   Telemetry Badges
   ===================== */
        .telemetry {
            position: absolute;
            top: 24px;
            left: 24px;
            display: flex;
            gap: 12px;
        }

        .badge {
            display: flex;
            align-items: center;
            gap: 8px;

            padding: 8px 14px;
            font-size: 13px;
            font-weight: 600;

            background: var(--glass-bg);
            backdrop-filter: blur(18px);
            border-radius: 12px;
            border: 1px solid var(--glass-border);

            box-shadow:
                inset 0 1px 0 var(--glass-highlight),
                0 6px 20px rgba(0, 0, 0, 0.4);
        }

        .status-dot {
            width: 9px;
            height: 9px;
            border-radius: 50%;
            background: #ff4d4d;
        }

        .status-dot.live {
            background: #00f5a0;
            box-shadow: 0 0 14px #00f5a0;
        }

        /* =====================
   SVG Icons
   ===================== */
        svg {
            width: 22px;
            height: 22px;
            stroke: currentColor;
            fill: none;
            stroke-width: 2;
        }

        /* =========================
   iOS / Mobile Fullscreen
   ========================= */

        .viewer-container.mobile-fs {
            position: fixed !important;
            inset: 0 !important;
            width: 100vw !important;
            height: 100dvh !important;
            /* iOS-safe */
            max-width: none !important;
            aspect-ratio: auto !important;
            border-radius: 0 !important;
            border: none !important;
            z-index: 9999;
        }

        /* Prevent page scrolling when fullscreen */
        body.mobile-fs {
            overflow: hidden;
            touch-action: none;
        }

        @media (hover: none) {
            .controls {
                opacity: 1 !important;
            }
        }
    </style>
</head>

<body>

    <div class="viewer-container" id="container">
        <div class="telemetry" id="telemetry">
            <div class="badge">
                <div class="status-dot" id="statusDot"></div>
                <span id="statusText">OFFLINE</span>
            </div>
            <div class="badge">
                <span id="fpsCounter">0 FPS</span>
            </div>
        </div>

        <canvas id="canvas"></canvas>

        <div class="placeholder" id="placeholder">
            <button class="primary" id="startBtn">
                WATCH
                <svg viewBox="0 0 24 24" style="fill:currentColor;stroke:none">
                    <polygon points="5 3 19 12 5 21"></polygon>
                </svg>
            </button>
        </div>

        <div class="controls" id="controls">
            <button id="stopBtn">
                <svg viewBox="0 0 24 24">
                    <rect x="6" y="4" width="4" height="16"></rect>
                    <rect x="14" y="4" width="4" height="16"></rect>
                </svg>
            </button>

            <button id="fsBtn">
                <svg viewBox="0 0 24 24">
                    <path
                        d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3" />
                </svg>
            </button>
        </div>
    </div>

    <script>
        "use strict";

        // --- Configuration ---
        const MAX_BUFFER_SIZE = 10 * 1024 * 1024; // 10MB
        const IDLE_TIME_MS = 2500;

        // --- DOM Elements ---
        const elements = {
            container: document.getElementById("container"),
            canvas: document.getElementById("canvas"),
            startBtn: document.getElementById("startBtn"),
            stopBtn: document.getElementById("stopBtn"),
            fsBtn: document.getElementById("fsBtn"),
            fpsCounter: document.getElementById("fpsCounter"),
            placeholder: document.getElementById("placeholder"),
            statusDot: document.getElementById("statusDot"),
            statusText: document.getElementById("statusText")
        };

        const ctx = elements.canvas.getContext("2d", { alpha: false, desynchronized: true });

        // --- State Variables ---
        let width = 0, height = 0;
        let abortController = null;
        let isStreaming = false;
        let streamBuffer = new Uint8Array(MAX_BUFFER_SIZE);

        // Rendering State
        let pendingFrame = null; // Holds the latest complete JPEG bytes
        let frameCount = 0;
        let fpsTimer = null;
        let animationId = null;

        // --- Event Listeners ---
        elements.startBtn.addEventListener("click", startStream);
        elements.stopBtn.addEventListener("click", stopStream);
        elements.fsBtn.addEventListener("click", toggleFullscreen);
        elements.container.addEventListener("mousemove", handleUserActivity);
        document.addEventListener("fullscreenchange", handleFullscreenChange);

        // --- Core Logic ---

        async function startStream() {
            if (isStreaming) return;

            // 1. Fetch Metadata
            try {
                const res = await fetch("/stream/dimensions");
                const data = await res.json();
                width = data.width;
                height = data.height;
                elements.canvas.width = width;
                elements.canvas.height = height;

                if (!document.fullscreenElement) {
                    elements.container.style.aspectRatio = `${width}/${height}`;
                }
            } catch (err) {
                console.error("Failed to fetch dimensions:", err);
                return;
            }

            // 2. Initialize State
            abortController = new AbortController();
            isStreaming = true;
            pendingFrame = null;
            frameCount = 0;

            // 3. Update UI
            updateUI(true);

            // 4. Start Loops
            fpsTimer = setInterval(updateFPS, 1000);
            renderLoop(); // Starts the drawing engine
            readStream(abortController.signal); // Starts the network engine
        }

        function stopStream() {
            if (abortController) abortController.abort();
            cleanup();
        }

        function cleanup() {
            isStreaming = false;
            if (animationId) cancelAnimationFrame(animationId);
            if (fpsTimer) clearInterval(fpsTimer);
            updateUI(false);
        }

        // --- Network Engine (Producer) ---
        async function readStream(signal) {
            let writeOffset = 0;
            let readOffset = 0;

            try {
                const response = await fetch("/stream", { method: "POST", signal });
                const reader = response.body.getReader();

                while (true) {
                    const { value, done } = await reader.read();
                    if (done) break;

                    // Buffer Management: Compact if needed
                    if (writeOffset + value.length > MAX_BUFFER_SIZE) {
                        // If we are about to overflow, shift valid data to start
                        if (readOffset < writeOffset) {
                            const remaining = streamBuffer.subarray(readOffset, writeOffset);
                            streamBuffer.set(remaining, 0);
                            writeOffset = remaining.length;
                            readOffset = 0;
                        } else {
                            // Hard reset if pointers are bad
                            writeOffset = 0;
                            readOffset = 0;
                        }
                    }

                    // Append new data
                    streamBuffer.set(value, writeOffset);
                    writeOffset += value.length;

                    // Parse Frames
                    // Header: 4 bytes (Little Endian Length)
                    while (writeOffset - readOffset >= 4) {
                        // Extract length using bitwise ops (fast)
                        const frameLen = (streamBuffer[readOffset]) |
                            (streamBuffer[readOffset + 1] << 8) |
                            (streamBuffer[readOffset + 2] << 16) |
                            (streamBuffer[readOffset + 3] << 24);

                        // Check if we have the full payload
                        if (writeOffset - readOffset >= 4 + frameLen) {
                            const start = readOffset + 4;
                            const end = start + frameLen;

                            // CRITICAL OPTIMIZATION:
                            // We slice (copy) the data here. This allows the network loop
                            // to immediately overwrite the buffer space without corrupting
                            // the frame waiting to be drawn.
                            // We overwrite 'pendingFrame', effectively dropping older frames
                            // if the renderer is running slower than the network.
                            pendingFrame = streamBuffer.slice(start, end);

                            readOffset += 4 + frameLen;
                        } else {
                            // Not enough data for the full frame yet
                            break;
                        }
                    }
                }
            } catch (err) {
                if (err.name !== 'AbortError') console.error("Stream error:", err);
            } finally {
                cleanup();
            }
        }

        // --- Rendering Engine (Consumer) ---
        async function renderLoop() {
            if (!isStreaming) return;

            if (pendingFrame) {
                const data = pendingFrame;
                pendingFrame = null; // Clear queue

                try {
                    // Create ImageBitmap directly from BufferSource (fastest)
                    const blob = new Blob([data], { type: 'image/jpeg' });
                    const bitmap = await createImageBitmap(blob);

                    // Draw and cleanup GPU memory immediately
                    ctx.drawImage(bitmap, 0, 0, width, height);
                    bitmap.close();

                    frameCount++;
                } catch (e) {
                    console.error("Render error:", e);
                }
            }

            animationId = requestAnimationFrame(renderLoop);
        }

        // --- UI Helpers ---
        function updateUI(active) {
            if (active) {
                elements.placeholder.classList.add("hidden");
                elements.statusDot.classList.add("live");
                elements.statusText.innerText = "LIVE";
            } else {
                elements.placeholder.classList.remove("hidden");
                elements.statusDot.classList.remove("live");
                elements.statusText.innerText = "OFFLINE";
                elements.fpsCounter.innerText = "";
            }
        }

        function updateFPS() {
            elements.fpsCounter.innerText = `${frameCount} FPS`;
            frameCount = 0;
        }

        // --- Fullscreen & Idle Logic ---
        let idleTimer;

        function toggleFullscreen() {
            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);

            if (isIOS) {
                // Fake fullscreen for iOS
                const enabled = container.classList.toggle("mobile-fs");
                document.body.classList.toggle("mobile-fs", enabled);
                return;
            }

            // Standard fullscreen for desktop / Android
            if (!document.fullscreenElement) {
                container.requestFullscreen().catch(err => {
                    console.error(err);
                });
            } else {
                document.exitFullscreen();
            }
        }

        function handleUserActivity() {
            if (!document.fullscreenElement) return;

            elements.container.classList.remove("user-inactive");
            clearTimeout(idleTimer);

            idleTimer = setTimeout(() => {
                if (document.fullscreenElement) {
                    elements.container.classList.add("user-inactive");
                }
            }, IDLE_TIME_MS);
        }

        function handleFullscreenChange() {
            if (!document.fullscreenElement) {
                clearTimeout(idleTimer);
                elements.container.classList.remove("user-inactive");
                // Restore aspect ratio check in windowed mode
                if (width && height) elements.container.style.aspectRatio = `${width}/${height}`;
            }
        }
    </script>
</body>

</html>